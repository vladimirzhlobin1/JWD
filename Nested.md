Вопрос
На какие две группы разделяются классы, объявленные внутри другого класса?
Как они называются на инглише?
Ответ
Вложенные классы делятся на два вида: статические и не статические. Вложенные классы, объявленные как статические называются вложенными статическими (static nested classes). Не статические называются внутренними (inner classes). Вложенные классы — элементы содержащего их класса
Источник
http://easy-code.ru/lesson/java-nested-classes#:~:text=%D0%92%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B%20%D0%B4%D0%B5%D0%BB%D1%8F%D1%82%D1%81%D1%8F%20%D0%BD%D0%B0%20%D0%B4%D0%B2%D0%B0,%D0%BD%D0%B0%D0%B7%D1%8B%D0%B2%D0%B0%D1%8E%D1%82%D1%81%D1%8F%20%D0%B2%D0%BD%D1%83%D1%82%D1%80%D0%B5%D0%BD%D0%BD%D0%B8%D0%BC%D0%B8%20(inner%20classes).&text=%D0%92%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B%20%E2%80%94%20%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D1%8B%20%D1%81%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D1%89%D0%B5%D0%B3%D0%BE%20%D0%B8%D1%85%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0.

Вопрос
Для каких целей они используются?
Ответ
Вот некоторые причины использования вложенных классов:
Это хороший способ группировки классов, которые используются только в одном месте: если класс полезен только для одного другого класса, то логично будет держать их вместе. Вложение таких вспомогательных классов делает код более удобным.
Инкапсуляция: допустим, есть два класса A и B, классу B требуется доступ к свойству класса A, которое может быть приватным. Вложение класса B в класс A решит эту проблему, более того сам класс B можно скрыть от внешнего использования.
Улучшение читаемости и обслуживаемости кода: вложение малых классов в более высокоуровневые классы позволяет хранить код там, где он используется.
Источник
http://easy-code.ru/lesson/java-nested-classes#:~:text=%D0%92%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B%20%D0%B4%D0%B5%D0%BB%D1%8F%D1%82%D1%81%D1%8F%20%D0%BD%D0%B0%20%D0%B4%D0%B2%D0%B0,%D0%BD%D0%B0%D0%B7%D1%8B%D0%B2%D0%B0%D1%8E%D1%82%D1%81%D1%8F%20%D0%B2%D0%BD%D1%83%D1%82%D1%80%D0%B5%D0%BD%D0%BD%D0%B8%D0%BC%D0%B8%20(inner%20classes).&text=%D0%92%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B%20%E2%80%94%20%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D1%8B%20%D1%81%D0%BE%D0%B4%D0%B5%D1%80%D0%B6%D0%B0%D1%89%D0%B5%D0%B3%D0%BE%20%D0%B8%D1%85%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0.


Вопрос
Какие уровни доступа применяются к таким классам?
Ответ
Static default

Вопрос
Какие существуют варианты внутренних классов?

Ответ
Существуют четыре категории вложенных классов:
статический класс-член (static member class),
не статический класс-член (nonstatic member class),
анонимный класс (anonymous class)
и локальный класс (local class).
Источник
https://habr.com/ru/post/439648/

Вопрос
Пусть объявлен класс Outer, а внутри него публичный вложенный класс NestedPublic и публичный внутренний класс InnerPublic. Создайте экземпляры каждого класса:
а) внутри класса Outer,
б) извне класса Outer?
Ответ
InnerPublic innerPublic = new InnerPublic();
NestedPublic nestedPublic = new NestedPublic();


Вопрос
Пусть объявлен класс Outer, а внутри него приватный вложенный класс NestedPrivate и приватный внутренний класс InnerPrivate. Создайте экземпляры каждого класса:
а) внутри класса Outer,
б) извне класса Outer?
Ответ
Outer outerObject = new Outer();
Outer.InnerPublic innerPublic = outerObject.new InnerPublic();
Outer.NestedPublic nestedPublic = new Outer.NestedPublic();

Вопрос
Пусть объявлен класс Outer, а внутри него внутренний класс Inner. Как обратиться внутри класса Inner:
а) к экземпляру класса Inner,
б) к объемлющему экземпляру класса Outer?

Вопрос
Пусть объявлен класс Outer, а внутри него вложенный класс Nested. Как обратиться внутри класса Nested:
а) к экземпляру класса Nested,
б) к объемлющему экземпляру класса Outer?

Вопрос
Можно ли из вложенного класса обратиться к членам внешнего класса?
Если да, то приведите пример.
Ответ
Из объекта вложенного класса нельзя обращаться к нестатическим членам внешнего класса
Источник
http://developer.alexanderklimov.ru/android/java/innerclass.php#:~:text=%D0%B8%D0%B7%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B0%20%D0%B2%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0%20%D0%BD%D0%B5%D0%BB%D1%8C%D0%B7%D1%8F%20%D0%BE%D0%B1%D1%80%D0%B0%D1%89%D0%B0%D1%82%D1%8C%D1%81%D1%8F%20%D0%BA%20%D0%BD%D0%B5%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%BC%20%D1%87%D0%BB%D0%B5%D0%BD%D0%B0%D0%BC%20%D0%B2%D0%BD%D0%B5%D1%88%D0%BD%D0%B5%D0%B3%D0%BE%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0

Вопрос
Можно ли из внутреннего класса обратиться к экземпляру внешнего класса?
Если да, то приведите пример.
Ответ
Вы не можете создать экземпляр внутреннего класса без привязки к экземпляру внешнего класса.
Источник
http://pr0java.blogspot.com/2015/08/3-inner-classes.html

Вопрос
Можно ли определить экземпляр вложенного класса, не определяя экземпляры внешнего класса?
Ответ
не можем, сначала надо определить хоть один экземпляр внешнего класса

Вопрос
Есть ли ограничения на объявление локальных переменных в локальных внутренних классах?
Есть ли да, то какие?
Ответ
Локальный класс имеет доступ к членам класса, в котором он объявлен. В предыдущем примере
Также, локальный класс имеет доступ к локальным переменным. Локальные классы имеют доступ только к переменным, объявленным как final. Когда локальный класс обращается к локальной переменной, происходит «захват»  этой переменой. Например, конструктор PhoneNumber имеет доступ к локальной переменной numberLength  потому что она объявлена как final; numberLength — захваченная переменная.
Начиная с  Java SE 8, локальные классы имеют доступ к финальным (final) локальным переменным и параметрам, а также к неизменяемым (effectively final) переменным, т.е. к переменным, которые не изменились с момента инициализации. Например, предположим, что переменная numberLength объявлена не финальной, и вы добавили строчку в конструктор PhoneNumber:



Вопрос
Можно ли наследовать вложенные классы?
Если да, то приведите пример
Ответ.
Внутренние классы (inner classes) От внутреннего класса может наследоваться другой внутренний класс, объявленный в том же самом внешнем классе (или в его наследнике

Вопрос
Можно ли из подкласса обратиться к методу вложенного суперкласса?
Если да, то приведите пример.
Вопрос
Какие существуют варианты внутренних интерфейсов?
Вопрос
Можно ли объявить класс внутри интерфейса?
Если да, то есть ли ограничения? Приведите пример.
Ответ
Да,
public interface A {
static class B {
public static boolean verifyState( A a ) {
return (true if object implementing class A looks to be in a valid state)
}
}
}


Можно ли создать экземпляр анонимного класса на основе:
а) абстрактного класса?
б) интерфейса?
в) неабстрактного класса?
г) финального класса?
Если да, то приведите пример.

Дан следующий java-файл.
//-------------- begin --------------
class Runner {
public static void main(String[] args){
Something something = new Something();
something.doSomething(...);        //1
}
}
interface Smthable {
void doSmth();
}
class Something {
void doSomething(...) {            //2
smth.doSmth();
}
}
//--------------- end ---------------
1. Замените многоточия в строках 1 и 2 на такой код, чтобы приложение после запуска с помощью экземпляра анонимного класса, порожденного от интерфейса Smthable, вывело на консоль текст Hello, World.
2. Получите тот же результат, переместив:
   а) интерфейс Smthable внутрь класса Something,
   б) класс Something внутрь интерфейса Smthable.

Дан следующий java-файл.
//-------------- begin --------------
abstract class AbstractRunner {
abstract int getYear();
abstract class AbstarctInner {
abstract int getYear();
}
public static void main(String[] args) {
... //1
... //2
... //3
}
}
//--------------- end ---------------
Создайте в строке 1 ссылку runner на экземпляр подкласса класса AbstractRunner.
Создайте в строке 2 ссылку inner на экземпляр подкласса класса AbstractInner.
Выведите на консоль в строке 3 текст 2010;2015, используя данные ссылки.

Дан следующий java-файл.
//-------------- begin --------------
class Runner {
public static void main(String[] args) {
...     //1
}
}
class Outer {
class Inner {
void go() {
System.out.println("Gone!");
}
}
}    
//--------------- end ---------------
1. С помощью функционала классов Outer и Inner выведите на консоль в строке 1 текст Gone!.
2. Переместив класс Outer внутрь класса Runner, получите тот же результат:
   а) не изменяя строку 1.
   б) изменяя строку 1,

Что представляют собой элементы перечисления?
Подсказка. Откомпилируйте фабричный класс из задачи inheritance1 и посмотрите, какие получились .class-файлы

Как образуются имена вложенных и внутренних .class-файлов после компиляции?
Приведите примеры.

Вопрос
Может ли вложенный класс быть раннер-классом?
Если да, то приведите пример, иначе поясните, почему нет.
Ответ
Да
public static void test(Runnable runnable) {
System.out.println("Start");
runnable.run();
System.out.println("End");
}
Затем вызываем его из метода main:
public static void main(String[] args) {
test(() -> {
System.out.println("Do something");
});
}


Вопрос
Может ли внутренний класс быть раннер-классом?
Если да, то приведите пример, иначе поясните, почему нет.
Ответ
Да
public static void test(Runnable runnable) {
System.out.println("Start");
runnable.run();
System.out.println("End");
}
Затем вызываем его из метода main:
public static void main(String[] args) {
test(() -> {
System.out.println("Do something");
});
}

Вопрос
Может ли интерфейс иметь раннер-класс?
Если да, то приведите пример, иначе поясните, почему нет.
Ответ
нет

