Какие уровни доступа есть у класса на верхнем уровне, т.е. у внешнего класса?
Ответ.
private int b;
	static int h;
	protected int d;
	int f;
Источник
 https://javarush.ru/groups/posts/1988-modifikatorih-dostupa-private-protected-default-public

Что является членами класса?
Ответ.
Переменые – поля класса
методы

Что еще можно определить в классе кроме членов?
Ответ.
Внутренний класс
Конструкторы


Какие уровни доступа есть у членов класса?
Ответ.
Private, protected, default, public
Источник
https://javarush.ru/groups/posts/1988-modifikatorih-dostupa-private-protected-default-public

Какие модификаторы необходимы для определения константы:
Ответ.
1. класса, static
2. экземпляра класса?

Обратный вопрос. Допустим, у некоторого класса есть 4 следующих поля:
class SomeClass {
    private int a; защищенная переменная от изменений
    private final int b; защищенная окончательная запрещено наследование
private static int c; запрещено изменение
private static final int D; гарантирует, что этот экземпляр не подменится на что-то другое.
...
}

Как можно назвать данные поля в зависимости от комбинации модификаторов static и final?



Может ли класс не иметь ни одного конструктора? Почему?
Ответ.
Нет конструктор создается автоматически дефолтный

Перечислите отличия конструктора от метода.
Ответ
Главное отличие между конструкторами и методами в том, что конструкторы инициализируют объекты, создаваемые с помощью оператора new, в то время как методы выполняют операции с уже существующими объектами.
Конструкторы не могут быть вызваны напрямую; они вызываются когда объект создается с помощью ключевого слова new. Методы же, могут быть вызваны напрямую у объекта, который уже был создан.
Определение конструкторов и методов похожи. Они могут принимать параметры, иметь модификаторы (т.е. public), а так же имеют тело которое будет выполняться.
Конструкторы могут иметь только имя совпадающее с именем класса. Из них нельзя ничего возвращать, даже void, так как на самом деле они уже возвращают новый объект.
Методы выполняют операции данными как для существующих объектов, так и без создания объекта вовсе (статические методы).
Из конструкторов нельзя ничего возвращать, т.к. по сути они уже возвращают объект класса. Методы должны возвращать хотя бы void.
Источник.ru.stackoverflow.com/questions/1003286/Чем-отличаются-методы-от-конструкторов-в-java

Как и в каком месте можно вызвать из одного конструктора другой конструктор этого же класса?
Ответ. Можете вызвать один конструктор из другого в том же классе, или в надклассе, со следующими ограничениями:
•	Вызываемый конструктор должен быть в первой строке кода в вызывающем конструкторе.
•	Вложенный конструктор не может иметь никакой явной или неявной ссылки на "this". Таким образом, вы не можете попасть во внутренний класс.

Источник.
https://javarush.ru/groups/posts/793-vihzov-konstruktora-iz-konstruktora



Как и в каком месте можно вызвать конструктор суперкласса?
Ответ.
Конструктор суперкласса (базового класса) может быть вызван из подкласса (производного класса). Этот вызов осуществляется с помощью ключевого слова super. Вызов конструктора суперкласса должен быть осуществлен в теле конструктора подкласса первым.

Источник.
https://www.bestprog.net/ru/2019/06/07/java-inheritance-a-reference-to-a-subclass-object-calling-the-superclass-constructor-the-keyword-super-ru/

Что делает компилятор, если в конструкторе нет вызова другого конструктора или конструктора суперкласса?
Ответ.
Если конструктор не делает вызов конструктора super класса-предка (с аргументами или без аргументов), компилятор автоматически добавляет код вызова конструктора класса-предка без аргументов.
Источник. http://www.javable.com/javaworld/10_00/01/


Можно ли одновременно использовать конструкции this() и super() в одном и том же конструкторе?
Обоснуйте ответ.
Ответ.
Мы можем использовать super() и this () только в конструкторе, а не где-либо еще, любой попытка сделать это приведет к ошибке времени компиляции
мы должны сохранить либо super (), либо this () в качестве первой строки конструктор, но не оба одновременно
super используется для доступа к методам базового класса while this используется для доступа к методам текущего класса.

Может ли быть приватный уровень доступа у конструктора? Если да, то для каких целей он необходим?
Да, класс может иметь приватный конструктор. Это необходимо для того, чтобы запретить доступ к конструктору из других классов и оставить его доступным в пределах определенного класса.
Источник.
https://www.it-swarm.com.ru/ru/java/mozhet-li-konstruktor-v-java-byt-zakrytym/970022131/

Какие модификаторы может иметь конструктор?
Ответ. В конструкторе допускается применение модификаторов доступа, можно задать один из модификаторов: public, protected, private или без модификатора. Конструктор не может иметь модификаторов abstract, final, native, static или synchronized.
Источник.
https://javarush.ru/groups/posts/1391-konstruktorih-klassov-java-jdk-15

Конструктор принадлежит классу или экземпляру класса?
Ответ
Любой класс в Java имеет конструктор. Даже если мы не прописываем его, то компилятор Java сам создаёт для этого класса конструктор по умолчанию. Каждый раз, когда мы создаём новый объект (экземпляр класса), запускается конструктор.
Источник.
https://proselyte.net/tutorials/java-core/classes-and-objects/

Можно ли наследовать конструктор?
Ответ.
Конструктор — это блок кода, который позволяет вам создать объект класса и имеет то же имя, что и класс, без явного возвращаемого типа. Всякий раз, когда класс (дочерний класс) расширяет другой класс (родительский класс), подкласс наследует состояние и поведение в виде переменных и методов от своего суперкласса, но не наследует конструктор суперкласса.
Источник.
http://espressocode.top/constructors-not-inherited-java/

Если да, то приведите примеры.

Какой тип возвращаемого конструктором значения?



Дан класс.
class Null {
    //фрагмент 1
    Null Null() {
        return null;
    }
    //фрагмент 2
    Null() {
        return null;
    }
}
В каком фрагменте ошибка компиляции?  При вызове метода
Удалите этот фрагмент полностью.
Прокомментируйте оставшийся фрагмент и продемонстрируйте функционал класса.


Если метод имеет то же имя, как и класс, то каким образом транслятор определяет где метод, а где конструктор (см. пример выше)?
если метод имеет то же имя, что и класс, он должен иметь возвращаемый тип.



Дан класс.
class Name {
    String name;
    Name() {
        this(makeRandomName());
    }
    Name(String name) {
        super();
        this.name = name;
    }
    String makeRandomName() {
        int k = (int) (Math.random() * 3);
        String name = new String[] {"Alpha", "Beta", "Gamma"}[k];
        return name;
    }
    public String toString() {
        return name;
    }
    public static void main(String[] args) {
        System.out.println(new Name());
    }
}
Объясните причину ошибки компиляции.
Предложите минимум 2 способа исправления ошибки, использовать метод makeRandomName() обязательно.
то потому, что вы не можете вызвать метод экземпляра до того, как экземпляр создан. Кстати, позже в конструкторе можно вызвать метод экземпляра (хотя и не решение для вас).
    this.name = makeRandomName();
Static String

Дан класс.
class Int {
    int i;
    void inc(Int param) {
        //param = new Int();
        param.i++;
    }
    public static void main(String[] args) {
        Int obj = new Int();
        obj.inc(obj);
        System.out.println(obj.i);
    }
}
Изменится ли результат, если убрать комментарий? Да -0
Объясните, почему? Создается переменная со значением объект 0

В чем смысл конструкции this?
Ответ.

слово this требуется для того, чтобы метод мог сослаться на вызвавший его объект. На этом, собственно можно было бы и закончить
Как правило, применять this нужно в двух случаях:
1.	Когда у переменной экземпляра класса и переменной метода/конструктора одинаковые имена;
2.	Когда нужно вызвать конструктор одного типа (например, конструктор по умолчанию или параметризированный) из другого. Это еще называется явным вызовом конструктора.
Источник.
https://javarush.ru/groups/posts/608-kljuchevoe-slovo-this-v-primerakh

Перечислите случаи, когда используется конструкция this.

В каких случаях можно обойтись без неё, т.е. заменить другими синтаксическими возможностями. Если можно, то каким образом?

Super

Можно ли присвоить null ссылочной переменной this?
Ответ.
Нет, нельзя. В Java левая часть оператора присваивания должен быть переменной. "This" — это специальное ключевое слово, которое всегда дает текущий экземпляр класса. Это не любая переменная. Точно также, null нельзя присвоить переменной, используя ключевое слово “super” или любое другое подобное.
Источник
https://javarush.ru/groups/posts/780-java-core-voprosih-k-sobesedovaniju-ch-3
Перечислите случаи, когда используется статический блок?
Ответ.
Java предоставляет пользователю блок, известный как статический блок, который в основном используется для статической инициализации класса. Блок состоит из набора операторов, которые выполняются перед выполнением основного метода. Это связано с тем, что класс должен быть загружен в основную память перед его использованием, а статический блок выполняется во время загрузки класса. При определении количества статических блоков в программе блоки выполняются сверху вниз. Следует отметить, что статические блоки выполняются перед конструкторами, как показано в следующем


В каких случаях можно обойтись без него. Если можно, то каким образом?
Ответ.
Объявить переменные static

Перечислите случаи, когда используется логический блок?
Ответ.
При описании класса могут быть использованы логические блоки. Логическим блоком называется код, заключенный в фигурные скобки и не принадлежащий ни одному методу текущего класса, например:
{ /* код */ }
static { /* код */ }

Логические блоки чаще всего используются в качестве инициализаторов полей, но могут содержать вызовы методов и обращения к полям текущего класса. При создании объекта класса они вызываются последовательно, в порядке размещения, вместе с инициализацией полей как простая последовательность операторов, и только после выполнения последнего блока будет вызван конструктор класса. Операции с полями класса внутри логического блока до явного объявления этого поля возможны только при использовании ссылки this, представляющую собой ссылку на текущий объект.
Логический блок может быть объявлен со спецификатором static. В этом случае он вызывается только один раз в жизненном цикле приложения при создании объекта или при обращении к статическому методу (полю) данного класса.
Источник.
http://crypto.pp.ua/2010/06/logicheskie-bloki-java/


В каких случаях можно обойтись без него. Если можно, то каким образом?

Что входит в сигнатуру метода?
Ответ.
Сигнатура метода включает имя метода и перечень параметров.

Что значит ключевое слово native?
Ответ.
Native - это ключевое слово в java, которое используется для того, чтобы сделать нереализованную структуру (метод) подобной абстрактной, но она будет зависящей от платформы, такой как собственный код и выполняться из собственного стека, а не java-стека.
Источник.
https://javarush.ru/groups/posts/780-java-core-voprosih-k-sobesedovaniju-ch-3


Дан код.
public class BusinessTrip {
  …
  public String bynToStr(int value) {
    return (value / 100) + "." + (value / 10 % 10) + (value % 10);
  }
}

Есть ли в нем семантическая ошибка? – нет приведения типов
Если да, то обоснуйте.

Дан код.
public class Utility {
  private Utility() {
  }
  public String bynToStr(int value) {
    return (value / 100) + "." + (value / 10 % 10) + (value % 10);
  }
}
Есть ли в нем семантическая ошибка?

Если да, то предложите альтернативные варианты.


К каким данным можно обратиться в статическом методе?
Ответ.
К статическим переменным

Почему нельзя объявить статическое поле внутри метода?
Ответ.
Статические переменные используются, когда требуется только одна копия переменной. поэтому, если вы объявляете переменную внутри метода, такая Переменная не используется, она становится локальной только для работы.

Перечислите, какой код в классе можно выполнить до создания объекта.
Ответ.
Вызов метода
Инициализация переменной


В чем различие между объектом и экземпляром класса?
Ответ.
Объект-это уникальный объект, который содержит элементы данных и функции-члены вместе на языке ООП.
объект задает реализации методов и значения, которыми будут обладать члены данных в классе. экземпляр-это уникальная копия класса, представляющего объект. Когда создается новый экземпляр класса, JVM выделит пространство памяти для этого экземпляра класса.

Назовите три этапа создания экземпляра класса.

Охарактеризуйте отношение композиции между классами? Как оно реализуется?
Ответ.

Композицией называется такое отношение между классами, когда один является частью второго. Конкретно, композиция реализуется включением в класс поля, являющегося объектом другого класса.
public class Job {
    private String role;
    private long salary;
    private int id;

    public String getRole() {
        return role;
    }
    public void setRole(String role) {
        this.role = role;
    }
    public long getSalary() {
        return salary;
    }
    public void setSalary(long salary) {
        this.salary = salary;
    }
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
public class Person {
    //используем отношение has-a
    private Job job;

    public Person(){
        this.job=new Job();
        job.setSalary(1000L);
    }
    public long getSalary() {
        return job.getSalary();
    }
}





	public class TestPerson {
    public static void main(String[] args) {
        Person person = new Person();
        long salary = person.getSalary();
    }
}


Допустим, необходимо, чтобы метод возвращал два значения одного примитивного типа.
Предложите способы и подтвердите примерами.
Ответ.

public static int[] something(){
    int number1 = 1;
    int number2 = 2;
    return new int[] {number1, number2};
}

// Main class code
public static void main(String[] args) {
  int[] ret = something();
  System.out.println(ret[0] + ret[1]);
}


Допустим, необходимо, чтобы метод возвращал два значения разных примитивных типов.
Предложите способы и подтвердите примерами.
Ответ.
Coordinates getCoordinates() {

    double longitude = 10;
    double latitude = 12.5;
    String placeName = "home";

    return new Coordinates(longitude, latitude, placeName);

Что такое иммутабельный объект?
Ответ.
Класс неизменяемый, состояние его объектов изменить невозможно.

Опишите 2 способа создания иммутабельных объектов.
Подсказка. Способ 1 - класс материала в classes2.
Какой альтернативный?
Подсказка - ключевое слово final для полей не использовать.

Создайте иммутабельный класс для вещества по альтернативному способу.

Даны 2 класса.
final class Material {
    private final String name;
    private final double density;
    ...
}
class Runner {
    private static void printMaterial(final Material material) {
            System.out.println(material);
    }
    public static void main(String[] args) {
            Material steel = new Material("steel",7850);
            printMaterial(steel);
    }
}
В методе printMaterial() по ссылке material создается новый объект или имеется доступ к объекту new Material("steel",7850)?
Какой пример можно использовать для обоснования ответа?
досуп

Класс для комплексного числа содержит два поля:
class Complex {
    private double re;
    private double im;
    …
}
Реализуйте в данном классе методы: plus() для операции + и add() для +=.
Приведите пример использования каждого метода.

Реализуйте эти же методы при условии, что класс Complex является иммутабельным.

Для чего предназначен метод toString()?
Ответ.
Класс Object содержит метод toString(). Он используется для получения строкового представления объекта. Каждый раз, когда мы пытаемся вывести ссылку на Object, вызывается метод toString(). Если мы не определили в классе метод toString(), то будет вызван метод toString() класса Object
Источник.
https://www.internet-technologies.ru/articles/ispolzovanie-metoda-tostring-v-java.html
В каких случаях он вызывается?
Ответ.
Каждый объект имеет метод toString(), автоматически вызывающийся, когда объект должен быть представлен в виде текстового значения или когда объект участвует в выражении, где ожидается строка
Источник.
https://www.internet-technologies.ru/articles/ispolzovanie-metoda-tostring-v-java.html

Как реализован метод toString() в классе Object?
Ответ.
Car car = new Porsche();
System.out.println("My car is " + car);
Real
Car car = new Porsche();
String result = "My car is " + car.toString();
System.out.println(result);
‘

Для чего предназначен метод equals()?
Ответ.
Метод определяет, является ли объект, вызывающий метод, равным объекту, который передается в качестве аргумента.
public boolean equals(Object o)
Метод возвращает значение True, если аргумент не равен null и является объектом того же типа и с тем же числовым значением.
Источник.
 https://hr-vector.com/java/metod-equals

В каких случаях он вызывается?

Как реализован метод equals() в классе Object?
Ответ.
Более 150 реализаций
public class Employee {
public boolean equals(Object otherObject) {
if(this == otherObject) return true;
if(otherObject == null) return false;
if(getClass() != otherObject.getClass())
return false;
Employee other = (Employee) otherObject;

return name.equals(other.name)
&amp;&amp; salary = other.salary;
&amp;&amp; hireDay.equals(other.hireDay);
}
}
public boolean equals(Object obj) {
    return (this == obj);
}


В чем различие между методом equals() и операции ==?
Ответ.
Метод equals() обозначает отношение эквивалентности объектов. Эквивалентным называется отношение, которое является симметричным, транзитивным и рефлексивным. Но мы можем переопределять метод equals, задавая логику сравнения двух объектов. Отличия equals() от операции == в классе Object нет. Eсли объект ни на что не ссылается(null), то вызов метода equals этого объекта приведет к NullPointerException. У String equals перегружен. Оператор == (в случае с примитивными типами данных) сравнивает значения переменных и возвращает результат, НО в случае со ссылочными типами данных (объекты, массивы и т.д.) сравнивает ссылки на объекты в памяти компьютера, и на основании равенства или неравенства ссылок возвращает результат (true или false).

В каких случаях применение метода equals() и операции == эквивалентно?
Ответ.
Eclipse в стандартной конфигурации генерирует начало метода equals() следующим образом:
public boolean equals(Object obj) {
if (this == obj)
return true;
if (obj == null)
return false;
С чем связаны данные проверки, которые кажутся лишними?
Ответ.

Для любых не-null объектов x,
x.equals(null)
должно возвращать
false

Что такое garbage collection?
Ответ.
Minor Garbage Collection
Сборка мусора из пространства Young Generation называется Minor Garbage Collection. Этот тип сборки всегда запускается, когда JVM не может выделить место для нового объекта, то есть когда Eden Space заполняется. Таким образом, чем выше скорость выделения, тем чаще происходит Minor Garbage Collection.
Major Garbage Collection
Major Garbage Collection очищает Tenured (старое пространство). Поскольку Old Generation больше по размеру, сборка происходит реже, чем у Young Generation. Когда объекты исчезают из Old Generation, мы говорим, что произошел «большая сборка мусора». Сборщик Old Generation попытается предугадать, когда ему нужно начать сборку, чтобы избежать неудач в продвижении со стороны Young Generation. Сборщики отслеживают порог заполнения для Old Generation и начинают сборку, когда этот порог превышен. Если этого порога недостаточно для удовлетворения требований продвижения, запускается «Full Garbage Collection».
Full Garbage Collection
Full Garbage Collection очищает всю кучу — как молодые, так и старые пространства. Многие путаются между Major (только OLD поколение) и Full GC (Young + OLD (Heap)). Full Garbage Collection включает продвижение всех живых объектов от молодого до старого поколения после сборки и уплотнения старого поколения. Полная сборка мусора будет остановкой для Stop-the-World. Она следит за тем, чтобы новые объекты не выделялись и объекты не становились недоступными во время работы сборщика.
Перечислите случаи, когда JVM отдает управление на garbage collector.

Источник.
https://javarush.ru/groups/posts/3197-kofe-breyk-60-kak-rabotaet-sborka-musora-v-java-jvm-15-vazhnihkh-voprosov-pro-spring-na-tekhnic

Как сделать так, чтобы JVM сразу перешла в режим сборки мусора?
Ответ.
jvmtiError ForceGarbageCollection(jvmtiEnv* env)

System.gc ();
System.runFinalization ();



Гарантирует ли garbage collector, что приложение в любом случае не будет иметь проблемы с недостатком памяти?
Ответ.
нет
Обоснуйте ответ.
Ответ.
GC удаляет неиспользуемые объекты но количество использованных может превысить порок для памяти

Для чего предназначен метод finalize()?
Ответ.
— Этот метод есть у класса Object и, следовательно, есть в каждом классе (все классы в Java считаются унаследованными от класса Object и содержат копию его методов). Ты можешь просто написать в твоём классе такой же метод, и он будет вызываться перед уничтожением объектов этого класса.

Какой недостаток у метода?
Ответ.

•  Одна из самых неприятных проблем возникающих при использовании метода finalize — это реордеринг. Представьте, что у вас есть два объекта с переопределенным методом finalize, один из которых ссылается на другой. Так вот, если эти объекты стали недостижимы, то порядок вызова методов финализации произойдет в случайном порядке. Таким образом, у вас будет потенциальная опасность вызвать какой-нибудь метод на уже финализированном объекте из метода finalize другого объекта и получить ошибку. Причем проблема будет возникать не на каждом объекте, что добавит головной боли при отладке.
•  Согласно Джошуа Блоху, автору знаменитой книги «Effective Java: Programming Language Guide», для объектов с переопределенным методом finalize аллокация и сборка может происходить в 430 раз медленнее, чем у обычного объекта.
•  Любые исключения выброшенные в теле метода будут проигнорированы
Источник
https://habr.com/ru/post/130370/
.
Для чего предназначены оболочечные классы?
Как они называются на инглише?

В чем преимущество примитивных типов перед соответствующими оболочечными классами?
Ответ.
Классы-обертки позволяют нивелировать недостатки, которые есть у примитивных типов. Самый очевидный из них — примитивы не имеют методов. Например, у них нет метода toString(), поэтому ты не сможешь, например, преобразовать число int в строку.
 public static void main(String[] args) {

   Integer i = new Integer(432);

   String s = i.toString();
}
Возникнут сложности и с обратным преобразованием. Допустим, у нас есть строка, про которую мы точно знаем, что она содержит число. Тем не менее, в случае с примитивным типом int мы никак не сможем это число из строки достать и превратить, собственно, в число.
public static void main(String[] args) {

   String s = "1166628";

   Integer i = Integer.parseInt(s);

   System.out.println(i);
Источник.
https://javarush.ru/groups/posts/1948-objertki-raspakovka-i-zapakovka


Что такое autoboxing и unboxing?
Ответ.
Обертки:
•	Позволяют не нарушать принцип “все является объектом”, благодаря чему числа, символы и булевы значения true/false не выпадают из этой концепции
•	Расширяют возможности работы с этими значениями, предоставляя удобные методы и поля
•	Необходимы, когда какой-то метод может работать исключительно с объектами

Примитивы не являются объектами. Но при этом переменной класса-обертки можно присваивать значение примитивного типа. Этот процесс называется автоупаковкой (autoboxing). Точно так же переменной примитивного типа можно присваивать объект класса-обертки. Этот процесс называется автораспаковкой (autounboxing). public class Main {
   public static void main(String[] args) {
       int x = 7;
       Integer y = 111;
       x = y; // автораспаковка
       y = x * 123; // автоупаковка
   }
}
Источник.
https://javarush.ru/groups/posts/1948-objertki-raspakovka-i-zapakovka

Дан код:
Ответ.
Integer (автоупаковка) a = 3, b =7;автораспоковка
Long c = a + b; автораспаковка

Перечислите все операции, где задействованы autoboxing и unboxing.

Дан корректный раннер-класс.
Будет ли ошибка компиляции, если удалить модификатор static из сигнатуры метода main()?
Обоснуйте ответ.
Что произойдет, если отправить на выполнение измененный класс?
Ответ.
Error: Main method is not static in class by.epam.lab.Runner, please define the main method as:
   public static void main(String[] args)
Статический метод можно вызвать без создания экземпляра объекта. Поэтому main() должен быть статическим, чтобы позволить ему быть запись в вашей программе. Как говорит Дэвид, вы можете просто добавить ключевое слово static к определению функции, чтобы изменить его.
Источник.
https://askdev.ru/q/pochemu-main-dolzhna-byt-statichnoy-67681/

Дан класс.
class Runner {
    public static void main(String[] args) {
            System.out.println("Hello, world!");
    }
}
Запрещается изменять синий код, т.е. метод main().
Добавить код в класс Runner, так чтобы в результате запуска этого класса из под JVM в консоли был следующий результат:
Ответ.
I am java.
Hello, world!
public class Rubber {
	    public static void main(String[] args) {
	            System.out.println("Hello, world!");
	    }

	    static
	    {
	        System.out.println("I am java.\n"+"Hello World");
	        System.exit(0);

	    }
	    }

