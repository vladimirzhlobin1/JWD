+ Questions
+
+**Theory**
+
+Что такое JVM?
+**Ответ.** Это среда программирования
я на Java существует с конца 1990-х годов. Она со¬
стоит из языка Java и поддерживающей его исполняющей системы, иначе называемой виртуальной машиной Java (JVM), а
применяемые технологии имеются спецификации, соответствующие данной среде. И эти стандарты дают разработчику и
потребителю уверенность, что технология будет совместима с другими компонентами, даже если они от поставщика иной
технологии.Java состоит из нескольких различных, хотя и связанных  вместе сред и спецификаций, в том числе Java
Moblle Edition (Java МЕ) 1,Java Standard Edition (Java SE) и Java Enterprise Edition (Java ЕЕ). JVM -это программа,
предоставляющая исполняющую среду, которая требуется для выполнения программ на Java. Программы на Java не могут
выполняться, если отсутствует JVM для соответствующих аппаратных средств и операционной системы на той платформе,
где требуется их выполнить. Правда, виртуальная машина JVM перенесена для выполнения на большом числе платформ: от
игровых приставок и проигрывателей формата Blu-ray до больших ЭВМ.
В итоге JVM порождается как процесс операционной системы, предоставляющий исполняющую среду Java, а затем заданная
программа выполняется в контексте только что запущенной (и пустой) виртуальной машины.JVM принимает программу для
выполнения, эта программа не предоставляется в исходном коде на языке Java. Вместо
этого исходный код на языке Java должен быть предварительно преобразован (или скомпилирован) в форму, называемую
байт-кодом Java. Такой байт-код должен быть предоставлен JVM в формате файлов классов с расширением .class. Виртуальная
машина JVM предоставляет среду выполнения для программы. Она запускает интерпретатор байт-кодовой
формы программы, последовательно выполняющий инструкции в байт-коде. Но в рабочих JVM пре¬доставляется также
динамический компилятор, ускоряющий выполнение важных частей программы, заменяя их равнозначным скомпилированным
машинным кодом.В соответствии с этой целью JVM служит контейнером для прикладного кода.
+**Источник.** О.Рейли, “Cправочник разработчика” стр. 34-35
+ Что такое JDK?
+**Ответ.** JDK - это среда разработки для создания приложений и компонентов с использованием языка программирования
+ Java.
JDK включает инструменты, полезные для разработки, тестирования и мониторинга программ, написанных на языке
программирования Java и работающих на платформе Java.
+**Источник.** https://www.oracle.com/java/technologies/javase/jdk17-readme-downloads.html
+ Что такое JRE?
+**Ответ.** JRE (Java Runtime Environment) - минимальная реализация виртуальной машины, необходимая для исполнения Java
приложений, без компилятора и других средств разработки. Состоит из виртуальной машины и библиотек Java классов.
+**Источник.** https://docs.oracle.com/goldengate/1212/gg-winux/GDRAD/java.htm#BGBFJHAB
+ Даны корректные исходные файлы: Hello.java и hello.cpp. Каждый из них преобразуется в исполняемый код, который
+ запускается на выполнение. Назовем данный процесс жизненным циклом приложения. В чем отличие жизненных циклов
+ этих приложений?
+ Перечислите группы примитивных типов данных и состав каждой группы.
+**Ответ.** Целочисленный типы данных:
int
short
long
bуtе
Числовые типы данных с плавающей точкой
float
douЫe
Тип данных CHAR
Значение в Юнмкоде
\Ь Возврат на одну позицию \u0008
\t Табуляция \u0009
\n Переход на новую строку \uOOOa
\r Возврат каретки \uOOOd
\" Двойная кавычка \u0022
\' Одинарная кавычка \u0027
\\ Обратная косая черта \uOOSc
Тип данных boolean имеет два логических значения: false и true, которые служат
для вычисления логических выражений. Преобразование значений типа boolean
в целочисленные и наоборот невозможно.
+**Источник.** "Java. Библиотека профессионала. Том 1" Хорстман стр. 57-59.
+ Какой размер данного булевского типа?
+**Ответ.** Размер не установлен и зависит от реализации конкретной JVM
+**Источник.** "Java. Библиотека профессионала. Том 1" Хорстман стр. 53-54.
+ Какой размер данного символьного типа?
+**Ответ.** 16 бит.
+**Источник*.* The Java Language Specification, Java SE 17 Edition.
+ Какими литералами можно инициализировать символьную переменную?
+**Ответ.** Для представления символов типа char в Java используется кодировка в Unicode, определяющая полный набор
международных символов на всех известных языках мира. Символьные литералы могут быть представлены в виде символа
заключенного в одинарные кавычки. Существует также механизм для непосредственного ввода значения символа в
восьмеричной или шестнадцатеричной форме. Для ввода значений в восьмеричной форме служит символ обратной косой
черты, за которым следует трехзначное число. Символ обратной косой черты может быть использован для обозначения
символов не имеющих точного написания, например символ перевода строки, табуляции, backspace, двойные и
одинарные кавычки.
**Источник.** https://www.examclouds.com/ru/java/java-core-russian/literals-russian
+Какие есть виды переменных?
+**Ответ.** Примитивные byte, short, char, int, long;
дробные или с плавающей точкой — float, double;
логические — boolean и ссылочные(создаются с применением конструкторов классов и нужны для доступа к объектам).
+**Источник.** стр. 53 https://docs.oracle.com/javase/specs/jls/se17/jls17.pdf.
+ В какой области памяти хранятся локальные переменные?
+ **Ответ.** Для оптимальной работы приложения JVM делит память на область стека (stack) и область кучи (heap).
Всякий раз, когда мы объявляем новые переменные, создаем объекты или вызываем новый метод, JVM выделяет память
для этих операций в стеке или в куче.Стек работает по схеме LIFO (последним вошел, первым вышел). Всякий раз,
когда вызывается новый метод, содержащий примитивные значения или ссылки на объекты, то на вершине стека под них
выделяется блок памяти. Из этого можно сделать вывод, что стек хранит значения примитивных переменных,
создаваемых в методах, а также ссылки на объекты в куче на которые ссылается метод.
Когда метод завершает выполнение, блок памяти (frame), отведенный для его нужд, очищается, и пространство
становится доступным для следующего метода. При этом поток выполнения программы возвращается к месту вызова
этого метода с последующим переходом к следующей строке кода.Эта область памяти используется для динамического
выделения памяти для объектов и классов JRE во время выполнения. Новые объекты всегда создаются в куче, а ссылки
на них хранятся в стеке.
Эти объекты имеют глобальный доступ и могут быть получены из любого места программы.
Эта область памяти разбита на несколько более мелких частей, называемых поколениями:
1. Young Generation — область где размещаются недавно созданные объекты. Когда она заполняется, происходит
2. быстрая сборка мусора
3. Old (Tenured) Generation — здесь хранятся долгоживущие объекты. Когда объекты из Young Generation достигают
4. определенного порога «возраста», они перемещаются в Old Generation
5. Permanent Generation — эта область содержит метаинформацию о классах и методах приложения, но начиная с Java 8
6. данная область памяти была упразднена. Подробнее об этом можно узнать из нашей прошлой статьи, а также
7. посмотрев видео
Мы можем управлять размерами кучи в зависимости от наших требований.
Помимо рассмотренных ранее, куча имеет следующие ключевые особенности:
Когда эта область памяти полностью заполняется, Java бросает java.lang.OutOfMemoryError
Доступ к ней медленнее, чем к стеку
Эта память, в отличие от стека, автоматически не освобождается. Для сбора неиспользуемых объектов используется
сборщик мусора
В отличие от стека, куча не является потокобезопасной и ее необходимо контролировать, правильно синхронизируя код
+ **Источник.**  https://topjava.ru/blog/stack-and-heap-in-java.
+ В какой области памяти хранятся аргументы метода?
+ В какой области памяти хранятся объекты?
+ В какой области памяти хранятся ссылки на объекты?
+ В какой области памяти хранятся массивы?
+**Ответ.** Heap
+**Источник.** https://docs.oracle.com/javase/specs/jls/se17/jls17.pdf.
+ Дайте определение массива.
+ **Ответ.** В языке программирования Java массивы являются объектами (§4.3.1), который динамически создан и может
быть назначен переменным типа Object (§4.3.2). Все методы класса Object могут быть вызваны в массиве. Объект массива
содержит ряд переменных. Количество переменных может быть равно нулю, и в этом случае массив называется пустым.
Переменные, содержащиеся в массиве, не имеют имен, вместо этого на них ссылаются выражения доступа к массиву,
которые используют неотрицательные целочисленные значения индекса. Эти переменные называются компонентами массива.
Если в массиве n компонентов, мы говорим, что n - длина массива а для ссылок на компоненты массива используются
целочисленные индексы от 0 до n - 1, включительно. Все компоненты массива имеют один и тот же тип, называемый
типом компонента массив. Если типом компонента массива является T, то тип самого массива пишется T []. Тип
компонента массива может сам быть типом массива. Компоненты такого массива могут содержать ссылки на подмассивы.
Если, начиная с любого массива типа, рассматривается его компонентный тип, а затем (если это также тип массива)
компонентный тип этого типа и т. д., в конечном итоге нужно достичь компонента тип, не являющийся типом массива,
это называется типом элемента исходного массива, и компоненты на этом уровне структуры данных называются элементами
исходный массив. В некоторых ситуациях элемент массива может быть массивом: если тип элемента - Object, Cloneable
или java.io.Serializable, затем некоторые или все элементов могут быть массивами, потому что любой объект массива
может быть назначен любому переменная этих типов.
+**Источник.** стр. 399 https://docs.oracle.com/javase/specs/jls/se17/jls17.pdf
+ Назовите 3 этапа создания массива. Какие действия выполняет JVM на каждом этапе
+**Ответ.** Декларация – в этом шаге мы указываем тип данных и размер массива, который мы собираемся создать.
Но помните, мы пока не упоминаем размеры измерений. Они остаются пустыми.
Создание экземпляров – на этом шаге мы создаем массив или выделяем память для массива, используя ключевое слово new.
Именно на этом шаге мы упоминаем размеры измерений массива.
int[] array = newint[5]. Когда JVM встречает new ключевое слово, он понимает, что он должен выделить память на что-то.
И указав int[5], мы имеем в виду, что мы хотим массив ints, размера 5. Таким образом, JVM создает память и назначает
ссылку на вновь выделенную память массиву, который является "ссылкой" типа int[].
Инициализация – массив, всегда инициализируется значением по умолчанию для типа данных. Но мы можем сделать наши
собственные инициализации.
+**Источник.** https://docs.oracle.com/javase/specs/jls/se17/jls17.pdf.
+ Приведите различные способы инициализации массива.
+**Ответ.**
dataType[] arrayName;
dataType arrayName[];(Си-вариант) не сильно распространён и не сильно приемлем.
+**Источник.** https://docs.oracle.com/javase/specs/jls/se17/jls17.pdf.
+ Дан массив
  int[] values = {...}; //в фигурных скобках корректный список инициализации.
  Есть ли различие в проходе по массиву циклами: for(int i=0; i < values.length; i++) {...}
  for(int value : values) {...}
  Если да, то в чем различие заключается?
  Как называется каждый цикл?
+**Ответ.**
В первом варианте индекс i принимает значение всех элементов массива поочередно занося их значения в последующем
созданную переменную над которой выполняется код.
в варианте - for(int value : values) {...}
автоматически values из списка загоняется в переменную типа int и в дальнейшем выполняется код ниже.
+**Источник.**
+ Можно ли создать массив нулевой длины? Если да, то для каких целей он необходим?
+**Ответ.** Да можно. это использовать его вместо null в ситуации, когда null не допускается. Одним из возможных
примеров этого является BlockingQueue массивов. Когда вы хотите сигнализировать конец ввода на сторону чтения.
BlockingQueue не принимает null. Но можно обернуть свой массив внутри класса
Массив нулевой длины может быть полезным: Чтобы вернуть массив, содержащий все элементы в списке:
<T>T[ ]toArray(T[ ] a).
+**Источник.**
+ Что собой представляет двумерный массив? Многомерный массив?
+**Ответ** Двумерный массив в Java — это массив массивов, то есть в каждой его ячейке находится ссылка на некий
массив. Но гораздо проще его представить в виде таблицы, у которой задано количество строк (первое измерение)
и количество столбцов (второе измерение). Многомерный массив в Java – это массив, содержащий массивы различных
размеров в качестве своих элементов. Его также называют “массив массивов”, или “неровный массив”.
+**Источник.** https://javarush.ru/groups/posts/mnogomernye-massivy.
+ Перечислите ссылочные типы.
+**Ответ.**
 Ссылочные типы  в языке Java включают:
  a.	Массивы
  b.	Классы
  c.	Интерфейсы
  d.	Перечисления
+**Источник.** https://docs.oracle.com/javase/specs/jls/se17/jls17.pdf.
+ Какая структура у java-файла (внутренности класса не указывать)?
+ Какие из элементов структуры являются обязательными?
+ Для чего предназначены пакеты?
+**Ответ.** Пакеты позволяют организовать классы логически в наборы. По умолчанию java уже имеет ряд встроенных
пакетов, например, java.lang, java.util, java.io и т.д. Кроме того, пакеты могут иметь вложенные пакеты.
Организация классов в виде пакетов позволяет избежать конфликта имен между классами. Ведь нередки ситуации,
когда разработчики называют свои классы одинаковыми именами. Принадлежность к пакету позволяет гарантировать
однозначность имен.Чтобы указать, что класс принадлежит определенному пакету, надо использовать директиву
package, после которой указывается имя пакетКак правило, названия пакетов соответствуют физической структуре
проекта, то есть организации каталогов, в которых находятся файлы с исходным кодом. А путь к файлам внутри
проекта соответствует названию пакета этих файлов. Например, если классы принадлежат пакету mypack, то эти
классы помещаются в проекте в папку mypack. Классы необязательно определять в пакеты. Если для класса пакет
не определен, то считается, что данный класс находится в пакете по умолчанию, который не имеет имени.
+**Источник.** Https://docs.oracle.com/javase/specs/jls/se17/jls17.pdf.
Как выглядит полное имя класса?
+**Ответ.** Полным именем класса или интерфейса в Java является:
  •	<имя package>.<имя класса>
  в случае, если класс или интерфейс не является вложенным в какой-либо другой класс или интерфейс.
  •	<полное имя класса, в который вложен наш класс>.<имя класса>
  в случае, если класс является вложенным
+**Источник.** https://docs.oracle.com/javase/specs/jls/se17/jls17.pdf.
Для чего предназначен оператор import?
**Ответ.** Для того чтобы определенные классы или весь пакет можно было сделать видимыми, в Java включен
оператор import ператор import служит только для удобства программистов и не является обязательным с технической
точки зрения для создания завершенной Java-программы. Однако если в приложении придется ссылаться на несколько
десятков классов, оператор import значительно уменьшит объем вводимого кода.
В исходном файле Java-программы операторы import должны следовать непосредственно за оператором package
(если таковой имеется) перед любыми определениями классов. Оператор import имеет следующую общую форму:
import пакет1 [.пакет2].(имя__класса|*);
+**Источник.** https://docs.oracle.com/javase/specs/jls/se17/jls17.pdf.
+ Для чего предназначен статический импорт?
+**Ответ.** Оператор import, предваряемый ключевым словом static, можно применять для импорта статических членов
класса или интерфейса. Благодаря статическому импорту появляется возможность ссылаться на статические члены
непосредственно по именам, не уточняя их именем класса.
+**Источник.** https://pro-java.ru/java-dlya-nachinayushhix/staticheskij-import-v-yazyke-java/#:~:
text=%D0%9E%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%20import%2C%20%D0%BF%D1%80%D0%B5%D0%B4%D0%B2%D0%B0%D1%80%D1%8
F%D0%B5%D0%BC%D1%8B%D0%B9%20%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%BC%20%D1%81%D0%BB%D0%BE%D0%B2%D0%BE%D0%BC,
%D0%B8%D0%BC%D0%B5%D0%BD%D0%B0%D0%BC%2C%20%D0%BD%D0%B5%20%D1%83%D0%B3%D0%BE%D1%87%D0%BD%D1%8F%D1%8F%20%D0%B8%D1%85%D
0%B8%D0%BC%D0%B5%D0%BD%D0%B5%D0%BC%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0..
+ Сколько внешних публичных классов можно объявить в одном java-файле?
**Ответ.** В одном физическом java-файле может быть только один публичный класс, имя которого должно совпадать с
именем файла и любое количество вложенных классов.Так же допускается в одном физическом файле размещать вместе
с public-классом отдельные не вложенные классы с уровнем доступа default/package/private, но так делать
не рекомендуется.
+В программе на Java может быт любое количество физических java-файлов, каждый из которых может содержать публичный
+ класс. Все эти классы могут вызываться напрямую из любого другого класса, если находятся в одной области видимости
+ (или через импорт, если в разных областях).
+**Источник.***
+ Может ли синтаксически правильный java-файл иметь имя 1.java? Если да, то какие ограничения?
+ Допустим, в одном java-файле объявлены два синтаксически правильных внешних класса. Какие могут быть
+ результаты компиляции данного файла?
  +**Ответ.** Возможен
**Источник.**
+Как записывается заголовок метода main() раннер-класса (т.е. класса, который может стартовать из-под JVM)?
  +**Ответ.** public static void main(String[] args)
  +**Источник.**
+ Это единственный способ?
  +**Ответ.** Да. До Java 6 включительно это можно было сделать с помощью блока статической инициализации.
+ Только если самостоятельно создать JVM.
+**Источник.**
+ Может ли один java-файл содержать два и более раннер-класса?
+ **Ответ.** Да, но не в основном классе.
+ Можно ли определить метод main() с другими модификаторами?
+**Ответ.** Да возможно.
+**Источник.**
+ Может ли в классе быть два и более метода main()?
+ Если да, то приведите пример.
+ **Ответ.** Да. 1. public static void main(String[] args){} - именно он будет точкой входа в программу.
2. public static void main(int[] args){}
+ Может ли в классе быть два метода main(), один из которых раннер, а второй метод main() отличается от первого
+ только отсутствием модификатора static?
+ Если да, то приведите пример вызова второго метода.
+ В корне проекта имеется файл HelloWorld.java, пути к необходимым ресурсам открыты.
+ Создайте bat-файл для запуска приложения на выполнение.
+ **Ответ** @echo off
javac HelloWorld.java
java Main
pause
+ В корне проекта имеется папка src для исходных java-файлов, а в ней – файл HelloArgs.java, который выводит
+ приветствие для каждого аргумента командной строки;папка bin для class-файлов. Пути к компилятору и JVM открыты,
+ переменная CLASSPATH не установлена. Создайте bat-файл для запуска приложения с двумя аргументами командной
+ строки clever и 25007 на выполнение.
+ **Ответ** javac -sourcepath src -d bin src/HelloArgs.java
  java -classpath bin HelloArgs clever 25007
+ Имеется корректный файл helloWorld.jar. создайте bat-файл для запуска приложения на выполнение.
+ **Ответ**java -jar helloWorld.jar
+ Какие есть виды комментариев?
+**Ответ.** Для этой цели используются два знака косой черты (/ /), а комментарий начинается сразу после знаков //
и продолжается до конца строки. Если же требуются комментарии, состоящие из нескольких строк, каждую их строку
следует начинать знаками / /, как показано ниже.
System.out.println("We willnotuse 'Hello, World! '"); // Мы не будем пользоваться избитой фразой "Здравствуй, мир!"
Остроумно, не правда ли?
Кроме того, для создания больших блоков комментариев можно использовать разделители / * и * /. И, наконец, третьей
разновидностью комментариев можно
пользоваться для автоматического формирования документации. Эти комментарии начинаются знаками/** и оканчиваются
знаками*/, как показано в листинге
+**Источник.** Библиотека профессионала Хорстманн 11 издание